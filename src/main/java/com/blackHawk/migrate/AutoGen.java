package com.blackHawk.migrate;

import com.blackHawk.migrate.Annotations.AddAnnotation;
import com.blackHawk.migrate.Annotations.ConditionalAnnotation;
import org.burningwave.core.assembler.ComponentSupplier;
import org.burningwave.core.classes.*;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.util.Pair;

import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Map;

import static org.burningwave.core.assembler.StaticComponentContainer.Constructors;

public class AutoGen {
    /*
    public static Object GenerateOld(String name, String packageName, Class interfaceRecipe)
    {
        var c = ClassSourceGenerator.create(
                TypeDeclarationSourceGenerator.create(name)
        ).addModifier(
                Modifier.PUBLIC
        ).addConcretizedType(
                interfaceRecipe
        );

        var methods = interfaceRecipe.getMethods();
        ArrayList<String> createdMethods = new ArrayList<>();
        for(var method : methods)
        {
            String fieldName = method.getName().toLowerCase(Locale.ROOT).substring(3);

            if(!createdMethods.contains(fieldName))
            {

                var field = VariableSourceGenerator.create(TypeDeclarationSourceGenerator.create(method.getReturnType()), fieldName);


                var ann = method.getAnnotation(AddAnnotation.class);
                if(ann != null)
                {
                    for(Class <?> a : ann.value())
                        field.addAnnotation(AnnotationSourceGenerator.create(a));
                }

                c.addField(field);
                createdMethods.add(fieldName);
            }

            var f = FunctionSourceGenerator.create(
                            method.getName()
                    ).setReturnType(TypeDeclarationSourceGenerator.create(method.getReturnType()))
                    .addModifier(Modifier.PUBLIC);


            if(method.getParameterCount() > 0)
            {
                f.addParameter(
                        VariableSourceGenerator.create(method.getParameterTypes()[0], "value")
                );

                f.addBodyCode(fieldName + " = " + "value;");

            }
            else
                f.addBodyCode("return " + fieldName + ";");

            c.addMethod(f);
        }

        UnitSourceGenerator unitSG = UnitSourceGenerator.create("com.blackHawk.AutoGenerated").addClass(c);

        ComponentSupplier componentSupplier = ComponentSupplier.getInstance();
        ClassFactory classFactory = componentSupplier.getClassFactory();

        ClassFactory.ClassRetriever classRetriever = classFactory.loadOrBuildAndDefine(unitSG);
        Class<?> generatedClass = classRetriever.get("com.blackHawk.AutoGenerated.AutoOrder");

        return Constructors.newInstanceOf(generatedClass);
    }
    */
    public static Pair<Class<?>, Object> Generate(String name, String packageName, Class interfaceRecipe, Class baseClass,Map<String, Boolean> annotationTags)
    {
        var c = ClassSourceGenerator.create(
                TypeDeclarationSourceGenerator.create(name)
        ).addModifier(
                Modifier.PUBLIC
        ).addConcretizedType(
                interfaceRecipe
        ).expands(
                baseClass
        ).addAnnotation(
                AnnotationSourceGenerator.create(Document.class)
                        .addParameter(VariableSourceGenerator.create("collection").setValue("\"Customer\""))
        );

        var methods = interfaceRecipe.getMethods();
        ArrayList<String> createdMethods = new ArrayList<>();
        for(var method : methods)
        {
            String fieldName = method.getName().substring(3);

            if(!createdMethods.contains(fieldName)) {

                Type[] generics = method.getGenericParameterTypes();

                TypeDeclarationSourceGenerator fieldType = TypeDeclarationSourceGenerator.create(method.getParameterTypes()[0]);


                try
                {
                    ParameterizedType parameterizedType = (ParameterizedType) generics[0];
                    System.out.print(parameterizedType.getActualTypeArguments()[0]);
                    fieldType.addGeneric(
                            GenericSourceGenerator.create(Class.forName(parameterizedType.getActualTypeArguments()[0].getTypeName()))
                    );
                }
                catch (ClassCastException | ClassNotFoundException ignored)
                {}


                var field = VariableSourceGenerator.create(fieldType, fieldName.toLowerCase(Locale.ROOT))
                        .addModifier(Modifier.PRIVATE);

                var ann = method.getAnnotation(AddAnnotation.class);
                if (ann != null) {
                    for (Class<?> a : ann.value())
                        field.addAnnotation(AnnotationSourceGenerator.create(a));
                }

                var condAnn = method.getAnnotation(ConditionalAnnotation.class);
                if(condAnn != null)
                {
                    if(annotationTags.get(condAnn.tag()))
                        field.addAnnotation(AnnotationSourceGenerator.create(condAnn.value()));
                    else if (!annotationTags.containsKey(condAnn.tag()) && condAnn.def())
                        field.addAnnotation(AnnotationSourceGenerator.create(condAnn.value()));
                }


                c.addField(field);
                createdMethods.add(fieldName);

                var getter = FunctionSourceGenerator.create("get" + fieldName)
                        .setReturnType(
                                fieldType
                        )
                        .addModifier(Modifier.PUBLIC)
                        .addBodyCode("return " + fieldName.toLowerCase() + ";");

                var setter = FunctionSourceGenerator.create(method.getName())
                        .setReturnType(
                                TypeDeclarationSourceGenerator.create(void.class)
                        )
                        .addModifier(Modifier.PUBLIC)
                        .addParameter(
                                VariableSourceGenerator.create(
                                        fieldType,
                                        "value"
                                )
                        )
                        .addBodyCode(fieldName.toLowerCase() + " = value;");

                c.addMethod(getter);
                c.addMethod(setter);


            }
        }




        UnitSourceGenerator unitSG = UnitSourceGenerator.create(packageName).addClass(c);

        ComponentSupplier componentSupplier = ComponentSupplier.getInstance();
        ClassFactory classFactory = componentSupplier.getClassFactory();

        ClassFactory.ClassRetriever classRetriever = classFactory.loadOrBuildAndDefine(unitSG);
        Class<?> generatedClass = classRetriever.get(packageName + "." + name);

        return Pair.of(generatedClass, Constructors.newInstanceOf(generatedClass));
    }

}
